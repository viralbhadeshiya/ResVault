/// <reference types="node" />
declare type BinaryString = string;
interface Binary {
    readonly len: number;
    str: BinaryString;
    chunks(size: number): Binary[];
    toNumber(): number;
    toHex(): string;
    kill(): void;
}
declare class BinaryImpl implements Binary {
    private binaryString;
    get str(): BinaryString;
    set str(v: string);
    get len(): number;
    private constructor();
    static new(s: BinaryString): Binary;
    static unsafeNew(s: BinaryString): Binary;
    static isValidBinaryString(s: BinaryString): boolean;
    static fromBytes(bytes: Buffer): Binary;
    static fromHex(hexString: string): Binary;
    protected setUnsafeStr(v: string): void;
    chunks(size: number): Binary[];
    toNumber(): number;
    toHex(): string;
    kill(): void;
}

declare type EntropyBits = '128' | '160' | '192' | '224' | '256';
/**
 *
 * @param entropyBitNum * original entropy bit number
 *                      * ('128' | '160' | '192' | '224' | '256')
 * @param checksum * attaching checksum
 *                 * (128 + 4 | 160 + 5 | 192 + 6 | 224 + 7 | 256 + 8) bits
 */
declare function export_default$4(entropyBitNum?: EntropyBits, checksum?: boolean): Binary;
declare function calcChecksum(bytes: Buffer): string;

declare type Language = 'english' | 'korean';
declare type RawMnemonicArray = string[];
declare type RawMnemonicIndexArray = number[];
interface Mnemonic {
    readonly len: number;
    readonly lang: Language;
    readonly raw: RawMnemonicArray;
    readonly rawIndex: RawMnemonicIndexArray;
    toString(): string;
    kill(): void;
}
declare class MnemonicImpl implements Mnemonic {
    readonly lang: Language;
    readonly raw: RawMnemonicArray;
    readonly rawIndex: RawMnemonicIndexArray;
    private constructor();
    static new(language: Language, rawArray: RawMnemonicArray): Mnemonic;
    static unsafeNew(language: Language, mnemonicArray: RawMnemonicArray, mnemonicIndexArray: RawMnemonicIndexArray): Mnemonic;
    get len(): number;
    static indexOfMnemonicWord(s: string, lang: Language): number;
    static isValidRawMnemonicArray(lang: Language, raw: RawMnemonicArray, callback?: (index: number) => void): boolean;
    toString(): string;
    kill(): void;
}

declare function export_default$3(entropy: Binary, language?: Language): Mnemonic;

declare function export_default$2(mnemonic: Mnemonic, passphrase?: string): Buffer;

declare function export_default$1(mnemonic: Mnemonic, withoutChecksum?: boolean): Binary;

declare const index_d_calcChecksum: typeof calcChecksum;
type index_d_Binary = Binary;
type index_d_BinaryImpl = BinaryImpl;
declare const index_d_BinaryImpl: typeof BinaryImpl;
type index_d_EntropyBits = EntropyBits;
type index_d_Mnemonic = Mnemonic;
type index_d_MnemonicImpl = MnemonicImpl;
declare const index_d_MnemonicImpl: typeof MnemonicImpl;
type index_d_Language = Language;
type index_d_RawMnemonicArray = RawMnemonicArray;
type index_d_RawMnemonicIndexArray = RawMnemonicIndexArray;
declare namespace index_d {
  export {
    export_default$4 as generateEntropy,
    index_d_calcChecksum as calcChecksum,
    index_d_Binary as Binary,
    index_d_BinaryImpl as BinaryImpl,
    index_d_EntropyBits as EntropyBits,
    export_default$3 as entropyToMnemonic,
    index_d_Mnemonic as Mnemonic,
    index_d_MnemonicImpl as MnemonicImpl,
    index_d_Language as Language,
    index_d_RawMnemonicArray as RawMnemonicArray,
    index_d_RawMnemonicIndexArray as RawMnemonicIndexArray,
    export_default$2 as mnemonicToSeed,
    export_default$1 as mnemonicToEntropy,
  };
}

declare type SeedOption = {
    passphrase?: string;
    bitsSize?: EntropyBits;
    language?: Language;
};
interface Seed {
    readonly privatekey: Buffer;
    readonly chaincode: Buffer;
    readonly buffer: Buffer;
    readonly mnemonic: Mnemonic;
    readonly entropy: Binary;
    kill(): void;
}
declare class export_default implements Seed {
    readonly entropy: Binary;
    readonly mnemonic: Mnemonic;
    readonly buffer: Buffer;
    static get defaultSeedOption(): SeedOption;
    static new(option?: SeedOption): Seed;
    /**
     *
     * @param src - Binary or (`Hex`)string;
     * @param option - SeedOption = {
                     - passphrase?: string;
                     - bitsSize?: EntropyBits;
                     - language?: Language;
                     - };
     * @returns
     */
    static fromEntropy(src: Binary | string, option?: SeedOption): Seed;
    static fromMnemonic(src: Mnemonic | string, option?: SeedOption): Seed;
    static fromSeed(src: Seed): Seed;
    readonly privatekey: Buffer;
    readonly chaincode: Buffer;
    private constructor();
    kill(): void;
}

export { Binary, EntropyBits, index_d as F, Language, Mnemonic, Seed, SeedOption, export_default as default };
